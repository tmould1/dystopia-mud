#!/usr/bin/env python3
"""
migrate_to_cfg.py - Migrate C files from acfg/balance to unified cfg system.

This script converts:
- acfg(ACFG_*) calls to cfg(CFG_ABILITY_*)
- balance.* accesses to cfg(CFG_COMBAT_*) or cfg(CFG_PROGRESSION_*)

Usage:
    python migrate_to_cfg.py <file.c>           # Preview changes
    python migrate_to_cfg.py <file.c> --apply   # Apply changes in-place

The script loads mappings from cfg_key_to_enum.json (generated by generate_cfg_keys.py).
"""

import re
import sys
import json
from pathlib import Path

SCRIPT_DIR = Path(__file__).parent
MAPPINGS_FILE = SCRIPT_DIR / "cfg_key_to_enum.json"


def load_mappings() -> dict:
    """Load migration mappings from JSON file."""
    if not MAPPINGS_FILE.exists():
        print(f"Error: {MAPPINGS_FILE} not found.")
        print("Run generate_cfg_keys.py first to create mappings.")
        sys.exit(1)

    with open(MAPPINGS_FILE, 'r') as f:
        return json.load(f)


def migrate_acfg_calls(content: str, acfg_to_cfg: dict) -> tuple[str, int]:
    """
    Replace acfg(ACFG_*) calls with cfg(CFG_ABILITY_*).
    Returns (new_content, replacement_count).
    """
    count = 0

    # Match acfg( ACFG_ENUM ) with various whitespace
    pattern = r'acfg\(\s*(ACFG_\w+)\s*\)'

    def replace_acfg(match):
        nonlocal count
        old_enum = match.group(1)
        if old_enum in acfg_to_cfg:
            new_enum = acfg_to_cfg[old_enum]
            count += 1
            return f'cfg( {new_enum} )'
        return match.group(0)  # Keep unchanged if not found

    new_content = re.sub(pattern, replace_acfg, content)
    return new_content, count


def migrate_balance_accesses(content: str, balance_to_cfg: dict) -> tuple[str, int]:
    """
    Replace balance.field accesses with cfg(CFG_*) calls.
    Returns (new_content, replacement_count).
    """
    count = 0

    # Build a mapping from balance field names to cfg enums
    field_to_cfg = {}
    for old, new in balance_to_cfg.items():
        # old is like "balance.base_damcap"
        # new is like "cfg(CFG_COMBAT_BASE_DAMCAP)"
        if old.startswith("balance."):
            field = old[8:]  # Remove "balance."
            field_to_cfg[field] = new

    # Match balance.field (word boundary to avoid partial matches)
    pattern = r'\bbalance\.(\w+)\b'

    def replace_balance(match):
        nonlocal count
        field = match.group(1)
        if field in field_to_cfg:
            count += 1
            return field_to_cfg[field]
        return match.group(0)  # Keep unchanged if not found

    new_content = re.sub(pattern, replace_balance, content)
    return new_content, count


def update_includes(content: str, has_acfg: bool, has_balance: bool) -> str:
    """
    Check if cfg.h include is needed.

    For now, we don't automatically add includes during migration.
    Files that include ability_config.h will get cfg() access after we
    add cfg.h to merc.h. We'll handle includes separately.
    """
    # Return content unchanged - we handle includes separately
    return content


def migrate_file(filepath: Path, apply: bool = False) -> None:
    """Migrate a single C file."""
    print(f"Processing {filepath}...")

    if not filepath.exists():
        print(f"Error: {filepath} not found.")
        return

    content = filepath.read_text(encoding='utf-8')
    mappings = load_mappings()

    # Perform migrations
    new_content, acfg_count = migrate_acfg_calls(content, mappings.get('acfg_to_cfg', {}))
    new_content, balance_count = migrate_balance_accesses(new_content, mappings.get('balance_to_cfg', {}))

    total = acfg_count + balance_count

    if total == 0:
        print("  No changes needed.")
        return

    print(f"  Found {acfg_count} acfg() calls to migrate")
    print(f"  Found {balance_count} balance.* accesses to migrate")

    # Update includes if we made changes
    if total > 0:
        new_content = update_includes(new_content, acfg_count > 0, balance_count > 0)

    if apply:
        # Write changes
        filepath.write_text(new_content, encoding='utf-8')
        print(f"  Applied {total} changes to {filepath}")
    else:
        # Show diff preview
        print(f"\n  Preview (use --apply to save changes):")
        print("  " + "-" * 60)

        old_lines = content.split('\n')
        new_lines = new_content.split('\n')

        shown = 0
        for i, (old, new) in enumerate(zip(old_lines, new_lines)):
            if old != new:
                print(f"  Line {i+1}:")
                print(f"    - {old.strip()}")
                print(f"    + {new.strip()}")
                shown += 1
                if shown >= 10:
                    remaining = sum(1 for o, n in zip(old_lines[i+1:], new_lines[i+1:]) if o != n)
                    if remaining > 0:
                        print(f"  ... and {remaining} more changes")
                    break


def main():
    if len(sys.argv) < 2:
        print("Usage: python migrate_to_cfg.py <file.c> [--apply]")
        print("       python migrate_to_cfg.py --all [--apply]")
        sys.exit(1)

    apply = '--apply' in sys.argv

    if '--all' in sys.argv:
        # Migrate all class files
        game_dir = SCRIPT_DIR.parent
        class_dir = game_dir / "src" / "classes"
        combat_dir = game_dir / "src" / "combat"

        files = list(class_dir.glob("*.c")) + list(combat_dir.glob("*.c"))
        for f in sorted(files):
            migrate_file(f, apply)
    else:
        filepath = Path(sys.argv[1])
        migrate_file(filepath, apply)


if __name__ == "__main__":
    main()
